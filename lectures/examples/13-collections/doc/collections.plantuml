@startuml Collections

set separator ::

package "Collections (java.util)" {

    interface Collection<E> extends Iterable{
        +boolean add(E obj)
        +boolean addAll(Collection<? extends E> c)
        +void clear()
        +boolean contains(Object obj)
        +boolean containsAll(Collection<?> c)
        +boolean equals(Object obj)
        +int hashcode()
        +boolean isEmpty()
        +Iterator<E> iterator()
        +boolean remove(Object o)
        +boolean removeAll(Collection<?> c)
        +boolean retainAll(Collection<?> c)
        +int size()
    }

    interface SequencedCollection<E> extends Collection<E>{
        +void addFirst(E e)
        +void addLast(E e)
        +E getFirst()
        +E getLast()  
        +E removeFirst()
        +E removeLast()
        +SequencedCollection<E> reversed()
    }

    interface List<E> extends SequencedCollection<E> {
        +void add(int index, E element)
        +boolean add(E e)
        +boolean addAll(int index, Collection<? extends E> c)
        +boolean addAll(Collection<? extends E> c)
        +void addFirst(E e)
        +void addLast(E e)
        +void clear()
        +boolean contains(Object o)
        +boolean containsAll(Collection<?> c)
        +static <E> List<E> copyOf(Collection<? extends E> coll)
        +boolean equals(Object o)
        +E get(int index)
        +E getFirst()
        +E getLast()
        +int hashCode()
        +int indexOf(Object o)
        +boolean isEmpty()
        +Iterator<E> iterator()
        +int lastIndexOf(Object o)
        +ListIterator<E> listIterator()
        +ListIterator<E> listIterator(int index)
        +static <E> List<E> of()
        +static <E> List<E> of(E e1)
        +static <E> List<E> of(E... elements)
        +static <E> List<E> of(E e1, E e2)
        +static <E> List<E> of(E e1, E e2, E e3)
        +static <E> List<E> of(E e1, E e2, E e3, E e4)
        +static <E> List<E> of(E e1, E e2, E e3, E e4, E e5)
        +static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6)
        +static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)
        +static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)
        +static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)
        +static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)
        +E remove(int index)
        +boolean remove(Object o)
        +boolean removeAll(Collection<?> c)
        +E removeFirst()
        +E removeLast()
        +void replaceAll(UnaryOperator<E> operator)
        +boolean retainAll(Collection<?> c)
        +List<E> reversed()
        +E set(int index, E element)
        +int size()
        +void sort(Comparator<? super E> c)
        +Spliterator<E> spliterator()
        +List<E> subList(int fromIndex, int toIndex)
        +Object[] toArray()
        +<T> T[] toArray(T[] a)
    }


    interface Set<E> extends Collection<E> {
        +boolean add(E e)
        +boolean addAll(Collection<? extends E> c)
        +void clear()
        +boolean contains(Object o)
        +boolean containsAll(Collection<?> c)
        +static <E> Set<E> copyOf(Collection<? extends E> coll)
        +boolean equals(Object o)
        +int hashCode()
        +boolean isEmpty()
        +Iterator<E> iterator()
        +static <E> Set<E> of()
        +static <E> Set<E> of(E e1)
        +static <E> Set<E> of(E... elements)
        +static <E> Set<E> of(E e1, E e2)
        +static <E> Set<E> of(E e1, E e2, E e3)
        +static <E> Set<E> of(E e1, E e2, E e3, E e4)
        +static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5)
        +static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6)
        +static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)
        +static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)
        +static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)
        +static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)
        +boolean remove(Object o)
        +boolean removeAll(Collection<?> c)
        +boolean retainAll(Collection<?> c)
        +int size()
        +Spliterator<E> spliterator()
        +Object[] toArray()
        +<T> T[] toArray(T[] a)
    }
    note top: coleção que não permite elementos duplicados

    interface SortedSet<E> extends Set<E> {
        +void addFirst(E e)
        +void addLast(E e)
        +Comparator<? super E> comparator()
        +E first()
        +E getFirst()
        +E getLast()
        +SortedSet<E> headSet(E toElement)
        +E last()
        +E removeFirst()
        +E removeLast()
        +SortedSet<E> reversed()
        +Spliterator<E> spliterator()
        +SortedSet<E> subSet(E fromElement, E toElement)
        +SortedSet<E> tailSet(E fromElement)
    }
    note top: coleção ordenada

    interface NavigableSet<E> extends SortedSet<E>{
        +E ceiling(E e)
        +Iterator<E> descendingIterator()
        +NavigableSet<E> descendingSet()
        +E floor(E e)
        +SortedSet<E> headSet(E toElement)
        +NavigableSet<E> headSet(E toElement, boolean inclusive)
        +E higher(E e)
        +Iterator<E> iterator()
        +E lower(E e)
        +E pollFirst()
        +E pollLast()
        +E removeFirst()
        +E removeLast()
        +NavigableSet<E> reversed()
        +NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
        +SortedSet<E> subSet(E fromElement, E toElement)
        +SortedSet<E> tailSet(E fromElement)
        +NavigableSet<E> tailSet(E fromElement, boolean inclusive)
    }

    interface Queue<E> extends Collection<E> {
        +boolean add(E e)
        +E element()
        +boolean offer(E e)
        +E peek()
        +E poll()
        +E remove()
    }
    note top: Fila (primeiro a entrar é o primeiro a sair - first-in, first-out)

    interface Deque<E> extends Queue<E> {
        +boolean add(E e)
        +boolean addAll(Collection<? extends E> c)
        +void addFirst(E e)
        +void addLast(E e)
        +boolean contains(Object o)
        +Iterator<E> descendingIterator()
        +E element()
        +E getFirst()
        +E getLast()
        +Iterator<E> iterator()
        +boolean offer(E e)
        +boolean offerFirst(E e)
        +boolean offerLast(E e)
        +E peek()
        +E peekFirst()
        +E peekLast()
        +E poll()
        +E pollFirst()
        +E pollLast()
        +E pop()
        +void push(E e)
        +E remove()
        +boolean remove(Object o)
        +E removeFirst()
        +boolean removeFirstOccurrence(Object o)
        +E removeLast()
        +boolean removeLastOccurrence(Object o)
        +Deque<E> reversed()
        +int size()
    }
    note top: fila duplamente encadeada, pode funcionar como fila ou pilha

    interface Map {
        +int size()
        +boolean isEmpty()
        +V get(Object key)
        +V put(K key, V value)
        +V remove(Object key)
        +Set<K> keySet()
        +Collection<V> values()
    }

    interface SortedMap extends Map {
        +Comparator<? super K> comparator()
        +K firstKey()
        +K lastKey()
    }

    class ArrayList<E> implements List<E>{
        +void add(int index, E element)
        +boolean add(E e)
        +boolean addAll(int index, Collection<? extends E> c)
        +boolean addAll(Collection<? extends E> c)
        +void addFirst(E element)
        +void addLast(E element)
        +void clear()
        +Object clone()
        +boolean contains(Object o)
        +void ensureCapacity(int minCapacity)
        +boolean equals(Object o)
        +void forEach(Consumer<? super E> action)
        +E get(int index)
        +E getFirst()
        +E getLast()
        +int hashCode()
        +int indexOf(Object o)
        +boolean isEmpty()
        +Iterator<E> iterator()
        +int lastIndexOf(Object o)
        +ListIterator<E> listIterator()
        +ListIterator<E> listIterator(int index)
        +E remove(int index)
        +boolean remove(Object o)
        +boolean removeAll(Collection<?> c)
        +E removeFirst()
        +boolean removeIf(Predicate<? super E> filter)
        +E removeLast()
        -void removeRange(int fromIndex, int toIndex)
        +boolean retainAll(Collection<?> c)
        +E set(int index, E element)
        +int size()
        +Spliterator<E> spliterator()
        +List<E> subList(int fromIndex, int toIndex)
        +Object[] toArray()
        +<T> T[] toArray(T[] a)
        +void trimToSize()
    }

    class LinkedList<E> implements List, Deque<E>{
        +void add(int index, E element)
        +boolean add(E e)
        +boolean addAll(int index, Collection<? extends E> c)
        +boolean addAll(Collection<? extends E> c)
        +void addFirst(E e)
        +void addLast(E e)
        +void clear()
        +Object clone()
        +boolean contains(Object o)
        +Iterator<E> descendingIterator()
        +E element()
        +E get(int index)
        +E getFirst()
        +E getLast()
        +int indexOf(Object o)
        +int lastIndexOf(Object o)
        +ListIterator<E> listIterator(int index)
        +boolean offer(E e)
        +boolean offerFirst(E e)
        +boolean offerLast(E e)
        +E peek()
        +E peekFirst()
        +E peekLast()
        +E poll()
        +E pollFirst()
        +E pollLast()
        +E pop()
        +void push(E e)
        +E remove()
        +E remove(int index)
        +boolean remove(Object o)
        +E removeFirst()
        +boolean removeFirstOccurrence(Object o)
        +E removeLast()
        +boolean removeLastOccurrence(Object o)
        +LinkedList<E> reversed()
        +E set(int index, E element)
        +int size()
        +Spliterator<E> spliterator()
        +Object[] toArray()
        +<T> T[] toArray(T[] a)
    }

    class HashSet implements Set<E> {
        +boolean add(E e)
        +void clear()
        +Object clone()
        +boolean contains(Object o)
        +boolean isEmpty()
        +Iterator<E> iterator()
        +static <T> HashSet<T> newHashSet(int numElements)
        +boolean remove(Object o)
        +int size()
        +Spliterator<E> spliterator()
        +Object[] toArray()
        +<T> T[] toArray(T[] a)
    }

    class LinkedHashSet extends HashSet<E> {
        
    }

    class TreeSet implements NavigableSet<E>{
        -TreeMap<E,Object> map
    }

    class HashMap {
        -Node<K,V>[] table
        -int size
    }

    class TreeMap {
        -Entry<K,V> root
        -int size
    }

    class PriorityQueue {
        -Object[] queue
        -int size
    }

    ' Relações
    Queue <|.. PriorityQueue
    Map <|.. HashMap
    SortedMap <|.. TreeMap
    }

@enduml